{"version":3,"file":"file-Cvg4hH3u.js","sources":["../../examples/csv-file-with-implicit-inner-nodes/csvdata.ts","../../examples/csv-file-with-implicit-inner-nodes/cbddata.ts","../../examples/csv-file-with-implicit-inner-nodes/treemap.ts","../../examples/csv-file-with-implicit-inner-nodes/index.html?html-proxy&index=1.js","../../examples/csv-file-with-implicit-inner-nodes/index.html?html-proxy&index=2.js"],"sourcesContent":["\n/* spellchecker: disable */\n\nimport * as gloperate from 'webgl-operate';\n\nimport log = gloperate.auxiliaries.log;\nimport LogLevel = gloperate.auxiliaries.LogLevel;\n\nimport { parse } from 'papaparse';\n\nimport { Configuration, Topology, NodeSort } from '../../source/treemap-renderer';\n\n/* spellchecker: enable */\n\n\nexport class CSVHeader {\n    public csv_delimiter: string;\n    public path_column: string;\n    public weight_column: string;\n    public height_column: string;\n    public color_column: string;\n    public label_column: string;\n    public height_scale: number;\n    public color_scheme: string;\n};\n\nclass Edge {\n    public parentIndex: number;\n    public index: number;\n};\n\n\nexport class CSVData {\n    protected static readonly FAILED = (url: string, request: XMLHttpRequest) =>\n        `fetching '${url}' failed (${request.status}): ${request.statusText}`;\n\n    protected static initializeHeader(header: CSVHeader): void {\n        header.csv_delimiter = ';';\n        header.path_column = 'name';\n    }\n\n    protected static parseHeader(lines: Array<string>, header: CSVHeader): void {\n        while (lines.length >= 1 && lines[0].startsWith('#')) {\n            const line = lines.shift()!.substring(1).trim();\n\n            const [key, value] = line.split('=').map((s: string) => s.trim());\n\n            if (key == 'delimiter') {\n                header.csv_delimiter = value || ';';\n            } else if (key == 'paths') {\n                header.path_column = value || 'name';\n            } else if (key == 'weights') {\n                header.weight_column = value || '';\n            } else if (key == 'heights') {\n                header.height_column = value || '';\n            } else if (key == 'colors') {\n                header.color_column = value || '';\n            } else if (key == 'labels') {\n                header.label_column = value || '';\n            } else if (key == 'heightScale') {\n                header.height_scale = Number.parseFloat(value || '0.1') || 0.1;\n            } else if (key == 'colorScheme') {\n                header.color_scheme = value || 'Greens';\n            } else {\n                log(LogLevel.Warning, `Unparsed header`, key, '=', value);\n            }\n        }\n    }\n\n    protected static parsePapaparseResult(result: any, header: CSVHeader, config: Configuration): void {\n        const collect_string_column = (result: any, name: string): Array<string> => {\n            if (result.meta.fields.indexOf(name) < 0) {\n                const column = new Array<string>(result.data.length);\n                return column;\n            }\n\n            const column = (result.data as Array<string>).map((row: any) => {\n                return row[name] ? row[name] : \"\";\n            });\n\n            return column;\n        };\n\n        const collect_column = (result: any, name: string) => {\n            if (result.meta.fields.indexOf(name) < 0) {\n                const column = new Array(result.data.length);\n                column.fill(-1);\n                return column;\n            }\n\n            const column = result.data.map((row: any) => {\n                return row[name] ? parseFloat(row[name]) : -1.0;\n            });\n\n            return column;\n        };\n\n        const has_labels_column = (name: string) => result.meta.fields.indexOf(name) >= 0;\n\n        // parse edges\n\n        const paths = collect_string_column(result, header.path_column);\n        for (let i = 0; i < paths.length; ++i) {\n            paths[i] = paths[i].replace(\"./\", \"\");\n        }\n        const pathParts = paths.map((value: string) => value.split('/'));\n\n        // parse weights\n\n        const leafWeights = collect_column(result, header.weight_column);\n\n        // parse heights\n\n        const leafHeights = collect_column(result, header.height_column);\n\n        // parse colors\n\n        const leafColors = collect_column(result, header.color_column);\n\n        // parse labels\n\n        const labels = has_labels_column(header.label_column) ?\n            collect_string_column(result, header.label_column) :\n            pathParts.map((parts: string[]) => parts.at(-1));\n\n        // Load topology\n\n        const createNode = (index: number, parentIndex: number): Edge => {\n            return { parentIndex, index } as Edge;\n        };\n\n        const gatherParentKey = (parts: string[], index: number): string => {\n            return \"/\" + parts.slice(0, index).join('/');\n        }\n\n        const edges = new Array<Configuration.NodeIdentifier>();\n        const names = new Map<number, string>();\n        const weights = new Array<number>();\n        const heights = new Array<number>();\n        const colors = new Array<number>();\n\n        const nodes = {};\n        let currentIndex = -1;\n\n        // Create root\n        nodes['/'] = createNode(currentIndex, -1);\n        currentIndex += 1;\n        weights.push(0);\n        heights.push(0);\n        colors.push(0);\n\n        // Create inner nodes and leaf nodes\n        pathParts.forEach((parts: Array<string>, partIndex: number) => {\n            parts.forEach((value: string, index: number) => {\n                const parentKey = gatherParentKey(parts, index);\n                const key = gatherParentKey(parts, index + 1);\n\n                if (!(parentKey in nodes)) {\n                    log(LogLevel.Warning, parentKey, 'not in', nodes);\n                    return;\n                }\n\n                if (key in nodes) {\n                    // Inner node already created\n                    return;\n                }\n\n                nodes[key] = createNode(currentIndex, nodes[parentKey].index);\n                edges.push(nodes[key].parentIndex);\n                edges.push(currentIndex);\n                names.set(currentIndex, value);\n                currentIndex += 1;\n\n                if (index == parts.length - 1) {\n                    // Is leaf node\n                    weights.push(leafWeights[partIndex]);\n                    heights.push(leafHeights[partIndex]);\n                    colors.push(leafColors[partIndex]);\n                } else {\n                    // Is inner node\n                    weights.push(0);\n                    heights.push(0);\n                    colors.push(0);\n                }\n            });\n        });\n\n        config.topology = {\n            edges: edges,\n            semantics: Topology.InputSemantics.ParentIdId,\n            format: Topology.InputFormat.Interleaved,\n        };\n\n        config.buffers = [\n            {\n                identifier: 'source-weights',\n                type: 'numbers',\n                data: weights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-heights',\n                type: 'numbers',\n                data: heights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-colors',\n                type: 'numbers',\n                data: colors,\n                linearization: 'topology',\n            }\n        ];\n\n        config.bufferViews = [\n            {\n                identifier: 'weights',\n                source: 'buffer:source-weights',\n                transformations: [\n                    { type: 'fill-invalid', value: 1.0, invalidValue: -1.0 },\n                    { type: 'propagate-up', operation: 'sum' }\n                ],\n            },\n            {\n                identifier: 'heights-normalized',\n                source: 'buffer:source-heights',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' }\n                ],\n            },\n            {\n                identifier: 'colors-normalized',\n                source: 'buffer:source-colors',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' },\n                    { type: 'callback', iteration: 'leaves', operation: (value: number) => Math.pow(value, 0.25) }\n                ],\n            }\n        ];\n\n        config.colors = [\n            { identifier: 'emphasis', colorspace: 'hex', value: '#00b0ff' },\n            { identifier: 'auxiliary', colorspace: 'hex', values: ['#00aa5e', '#71237c'] },\n            { identifier: 'inner', colorspace: 'hex', values: ['#e8eaee', '#eef0f4'] },\n            { identifier: 'leaf', preset: header.color_scheme, steps: 7 },\n        ];\n\n        config.layout = {\n            algorithm: 'snake',\n            weight: 'bufferView:weights',\n            sort: {\n                key: 'bufferView:weights',\n                algorithm: NodeSort.Algorithm.Keep\n            },\n            parentPadding: { type: 'relative', value: 0.05 },\n            siblingMargin: { type: 'relative', value: 0.05 },\n            accessoryPadding: {\n                type: 'absolute',\n                direction: 'bottom',\n                value: [0.0, 0.02, 0.01, 0.0],\n                relativeAreaThreshold: 0.4, targetAspectRatio: 8.0,\n            },\n        };\n\n        config.geometry = {\n            parentLayer: { showRoot: false },\n            leafLayer: {\n                colorMap: 'color:leaf',\n                height: 'bufferView:heights-normalized',\n                colors: 'bufferView:colors-normalized',\n            },\n            emphasis: { outline: new Array<number>(), highlight: new Array<number>() },\n            heightScale: header.height_scale,\n        };\n\n        config.labels = {\n            innerNodeLayerRange: [1, 2],\n            numTopInnerNodes: 50,\n            numTopWeightNodes: 50,\n            numTopHeightNodes: 50,\n            numTopColorNodes: 50,\n            names: names,\n        };\n\n        config.altered.alter('any');\n    }\n\n    static async loadAsync(file: File): Promise<Configuration> {\n        const data = await file.text();\n\n        const header = new CSVHeader();\n\n        CSVData.initializeHeader(header);\n\n        const lines = data.split('\\n');\n\n        CSVData.parseHeader(lines, header);\n\n        const payload = lines.join('\\n');\n\n        return this.loadAsyncHeader(payload, header);\n    }\n\n    static loadAsyncHeader(data: string, header: CSVHeader): Promise<Configuration> {\n        return new Promise<Configuration>((resolve, reject) => {\n            const config = new Configuration();\n\n            parse(data, {\n                error: (error: any) => reject(error),\n                complete: (result) => {\n                    CSVData.parsePapaparseResult(result, header, config);\n\n                    resolve(config);\n                },\n                delimiter: header.csv_delimiter,\n                quoteChar: '\"',\n                escapeChar: '\"',\n                header: true,\n                comments: '#',\n                skipEmptyLines: true\n            });\n        });\n    }\n\n}\n","\n/* spellchecker: disable */\n\nimport * as gloperate from 'webgl-operate';\n\nimport log = gloperate.auxiliaries.log;\nimport LogLevel = gloperate.auxiliaries.LogLevel;\n\nimport { CSV, Column, Float32Column, Float32Chunk, StringColumn, StringChunk } from '@hpicgs/cbd-parser';\n\nimport { Configuration, Topology, NodeSort } from '../../source/treemap-renderer';\nimport { delimiter } from 'path';\n\n/* spellchecker: enable */\n\nexport class CBDHeader {\n    public csv_delimiter: string;\n    public path_column: string;\n    public weight_column: string;\n    public height_column: string;\n    public color_column: string;\n    public label_column: string;\n    public height_scale: number;\n    public color_scheme: string;\n};\n\nclass Edge {\n    public parentIndex: number;\n    public index: number;\n};\n\nclass CBDHeaderParser {\n    protected _header: CBDHeader;\n    protected _loader: CSV;\n    protected _headerParsed = false;\n    protected _intermediateChunk = '';\n\n    public constructor(header: CBDHeader, loader: CSV) {\n        this._header = header;\n        this._loader = loader;\n    }\n\n    // do nothing on start\n    public start(): void { }\n\n    // do nothing on end\n    public flush(): void { }\n\n    public transform: TransformerTransformCallback<string, string> = async (chunk, controller) => {\n\n        if (this._headerParsed) {\n            controller.enqueue(chunk);\n\n            return;\n        }\n\n        this._intermediateChunk += chunk;\n\n        // Contains newline => let's parse the header line\n        let lastNewline = -1;\n        let nextNewline = this._intermediateChunk.indexOf('\\n', lastNewline + 1);\n        while (nextNewline != -1 && this._intermediateChunk[lastNewline + 1] == '#') {\n            const line = this._intermediateChunk.substring(lastNewline + 2, nextNewline).trim();\n\n            const [key, value] = line.split('=').map((s: string) => s.trim());\n\n            if (key == 'delimiter') {\n                this._header.csv_delimiter = value || ';';\n                this._loader._options!.delimiter = this._header.csv_delimiter;\n            } else if (key == 'paths') {\n                this._header.path_column = value || 'name';\n            } else if (key == 'weights') {\n                this._header.weight_column = value || '';\n            } else if (key == 'heights') {\n                this._header.height_column = value || '';\n            } else if (key == 'colors') {\n                this._header.color_column = value || '';\n            } else if (key == 'labels') {\n                this._header.label_column = value || '';\n            } else if (key == 'heightScale') {\n                this._header.height_scale = Number.parseFloat(value || '0.1') || 0.1;\n            } else if (key == 'colorScheme') {\n                this._header.color_scheme = value || 'Greens';\n            } else {\n                log(LogLevel.Warning, `Unparsed header`, key, '=', value);\n            }\n\n            lastNewline = nextNewline;\n            nextNewline = this._intermediateChunk.indexOf('\\n', lastNewline + 1);\n        }\n\n        if (lastNewline > 0) {\n            this._intermediateChunk = this._intermediateChunk.substring(lastNewline + 1);\n        }\n\n        // Next line doesn't start with # => parsing headers finished\n        if (!this._intermediateChunk.startsWith('#')) {\n            controller.enqueue(this._intermediateChunk);\n\n            this._intermediateChunk = '';\n            this._headerParsed = true;\n        }\n    };\n}\n\nexport class CBDData {\n    protected static initializeHeader(header: CBDHeader): void {\n        header.csv_delimiter = ';';\n        header.path_column = 'name';\n    }\n\n    protected static parseResult(result: Array<Column>, header: CBDHeader, config: Configuration): void {\n\n        const collect_string_column = (result: Array<Column>, name: string): Array<string> => {\n            let column_index = result.findIndex((column) => column.name == name);\n            if (column_index < 0) {\n                const column = new StringColumn(name);\n                column.push(new StringChunk(result[0].length, 0, false));\n                return column;\n            }\n\n            // Return column as is\n            return result[column_index];\n        };\n\n        const collect_column = (result: Array<Column>, name: string) => {\n            let column_index = result.findIndex((column) => column.name == name);\n            if (column_index < 0) {\n                const column = new Float32Column(name);\n                column.push(new Float32Chunk(result[0].length, 0, false))\n                column.getChunk(0).view.fill(-1);\n                return column;\n            }\n\n            /*const float32Flatten = (chunks) => {\n                const flattened = new Float32Array(result[0].length);\n\n                //insert each chunk into the new float32array\n                let currentFrame = 0\n                chunks.forEach((chunk) => {\n                    flattened.set(chunk, currentFrame)\n                    currentFrame += chunk.length;\n                });\n                return flattened;\n            }*/\n\n            //return float32Flatten(result[column_index].chunks.map(chunk => chunk.view));\n\n            // Return column as is\n            return result[column_index];\n        };\n\n        const has_labels_column = (name: string) => result.findIndex((column) => column.name == name && column.type == 'string') >= 0;\n\n        // parse edges\n\n        const paths = collect_string_column(result, header.path_column).chunks.map(chunk => chunk._data).flat();\n\n        for (let i = 0; i < paths.length; ++i) {\n            paths[i] = paths[i].replace(\"./\", \"\");\n        }\n        const pathParts = paths.map((value: string) => value.split('/'));\n\n        // parse weights\n\n        const leafWeights = collect_column(result, header.weight_column);\n\n        // parse heights\n\n        const leafHeights = collect_column(result, header.height_column);\n\n        // parse colors\n\n        const leafColors = collect_column(result, header.color_column);\n\n        // parse labels\n\n        const labels = has_labels_column(header.label_column) ?\n            collect_string_column(result, header.label_column) :\n            pathParts.map((parts: string[]) => parts.at(-1));\n\n        // Load topology\n\n        const createNode = (index: number, parentIndex: number): Edge => {\n            return { parentIndex, index } as Edge;\n        };\n\n        const gatherParentKey = (parts: string[], index: number): string => {\n            return \"/\" + parts.slice(0, index).join('/');\n        }\n\n        const edges = new Array<Configuration.NodeIdentifier>();\n        const names = new Map<number, string>();\n        const weights = new Array<number>();\n        const heights = new Array<number>();\n        const colors = new Array<number>();\n\n        const nodes = {};\n        let currentIndex = -1;\n\n        // Create root\n        nodes['/'] = createNode(currentIndex, -1);\n        currentIndex += 1;\n        weights.push(0.0);\n        heights.push(0.0);\n        colors.push(0.0);\n\n        // Create inner nodes and leaf nodes\n        pathParts.forEach((parts: Array<string>, partIndex: number) => {\n            parts.forEach((value: string, index: number) => {\n                const parentKey = gatherParentKey(parts, index);\n                const key = gatherParentKey(parts, index + 1);\n\n                if (!(parentKey in nodes)) {\n                    log(LogLevel.Warning, parentKey, 'not in', nodes);\n                    return;\n                }\n\n                if (key in nodes) {\n                    // Inner node already created\n                    return;\n                }\n\n                nodes[key] = createNode(currentIndex, nodes[parentKey].index);\n                edges.push(nodes[key].parentIndex);\n                edges.push(currentIndex);\n                names.set(currentIndex, value);\n                currentIndex += 1;\n\n                if (index == parts.length - 1) {\n                    // Is leaf node\n                    weights.push(leafWeights.get(partIndex) || 0.0);\n                    heights.push(leafHeights.get(partIndex) || 0.0);\n                    colors.push(leafColors.get(partIndex) || 0.0);\n                } else {\n                    // Is inner node\n                    weights.push(0.0);\n                    heights.push(0.0);\n                    colors.push(0.0);\n                }\n            });\n        });\n\n        config.topology = {\n            edges: edges,\n            semantics: Topology.InputSemantics.ParentIdId,\n            format: Topology.InputFormat.Interleaved,\n        };\n\n        config.buffers = [\n            {\n                identifier: 'source-weights',\n                type: 'numbers',\n                data: weights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-heights',\n                type: 'numbers',\n                data: heights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-colors',\n                type: 'numbers',\n                data: colors,\n                linearization: 'topology',\n            }\n        ];\n\n        config.bufferViews = [\n            {\n                identifier: 'weights',\n                source: 'buffer:source-weights',\n                transformations: [\n                    { type: 'fill-invalid', value: 1.0, invalidValue: -1.0 },\n                    { type: 'propagate-up', operation: 'sum' }\n                ],\n            },\n            {\n                identifier: 'heights-normalized',\n                source: 'buffer:source-heights',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' }\n                ],\n            },\n            {\n                identifier: 'colors-normalized',\n                source: 'buffer:source-colors',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' },\n                    { type: 'callback', iteration: 'leaves', operation: (value: number) => Math.pow(value, 0.25) }\n                ],\n            }\n        ];\n\n        config.colors = [\n            { identifier: 'emphasis', colorspace: 'hex', value: '#00b0ff' },\n            { identifier: 'auxiliary', colorspace: 'hex', values: ['#00aa5e', '#71237c'] },\n            { identifier: 'inner', colorspace: 'hex', values: ['#e8eaee', '#eef0f4'] },\n            { identifier: 'leaf', preset: header.color_scheme, steps: 7 },\n        ];\n\n        config.layout = {\n            algorithm: 'snake',\n            weight: 'bufferView:weights',\n            sort: {\n                key: 'bufferView:weights',\n                algorithm: NodeSort.Algorithm.Keep\n            },\n            parentPadding: { type: 'relative', value: 0.05 },\n            siblingMargin: { type: 'relative', value: 0.05 },\n            accessoryPadding: {\n                type: 'absolute',\n                direction: 'bottom',\n                value: [0.0, 0.02, 0.01, 0.0],\n                relativeAreaThreshold: 0.4, targetAspectRatio: 8.0,\n            },\n        };\n\n        config.geometry = {\n            parentLayer: { showRoot: false },\n            leafLayer: {\n                colorMap: 'color:leaf',\n                height: 'bufferView:heights-normalized',\n                colors: 'bufferView:colors-normalized',\n            },\n            emphasis: { outline: new Array<number>(), highlight: new Array<number>() },\n            heightScale: header.height_scale,\n        };\n\n        config.labels = {\n            innerNodeLayerRange: [1, 2],\n            numTopInnerNodes: 50,\n            numTopWeightNodes: 50,\n            numTopHeightNodes: 50,\n            numTopColorNodes: 50,\n            names: names,\n        };\n\n        config.altered.alter('any');\n    }\n\n    static loadAsync(file: File): Promise<Configuration> {\n        const header = new CBDHeader();\n\n        const loader = new CSV({ delimiter: ';' });\n\n        CBDData.initializeHeader(header);\n\n        const payload = file.stream()\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new TransformStream(new CBDHeaderParser(header, loader)))\n            .pipeThrough(new TextEncoderStream());\n\n        loader.addDataSource('file', payload);\n\n        return new Promise<Configuration>(async (resolve, reject) => {\n            const config = new Configuration();\n\n            const start = Date.now();\n            console.log('Start parsing:', start);\n\n            const detectedColumns = await loader.open('file');\n\n            const { columns, statistics } = await loader.load({\n                columns: detectedColumns,\n                /*\n                onInit: () => {\n                    console.log('received columns', detectedColumns);\n                    console.log(`detected ${detectedColumns!.length} columns:\\n` +\n                        detectedColumns!.map(({ name, type }) => `${name}: ${type}`).join('\\n')\n                    );\n                },*/\n                /*\n                onUpdate: (progress) => console.log(`received new data. progress: ${progress}`),\n                */\n            });\n\n            const parsed_csv = Date.now();\n            console.log('End CSV parsing:', parsed_csv, parsed_csv - start);\n\n            CBDData.parseResult(columns, header, config);\n\n            const parsed_config = Date.now();\n            console.log('End Config parsing:', parsed_config, parsed_config - parsed_csv);\n\n            console.log('Full runtime:', parsed_config - start);\n\n            resolve(config);\n        });\n    }\n\n}\n","\n\n/* spellchecker: disable */\n\nimport * as gloperate from 'webgl-operate';\n\nimport log = gloperate.auxiliaries.log;\nimport LogLevel = gloperate.auxiliaries.LogLevel;\n\nimport {\n    Configuration,\n    Renderer,\n    Visualization,\n    initialize\n} from '../../source/treemap-renderer';\n\nimport { CSVData } from './csvdata';\nimport { CBDData } from './cbddata';\n\nimport { Example } from '../example';\n\n/* spellchecker: enable */\n\n\n// tslint:disable:max-classes-per-file\n\nexport class ImplicitInnerNodesTreemapFromCSVExample extends Example {\n\n    get canvas(): gloperate.Canvas {\n        return this._canvas;\n    }\n\n    get visualization(): Visualization {\n        return this._visualization;\n    }\n\n    get renderer(): Renderer {\n        return this._renderer;\n    }\n\n    private _canvas: gloperate.Canvas;\n    private _visualization: Visualization;\n    private _renderer: Renderer;\n\n\n    validate(element: HTMLCanvasElement | string): boolean {\n        return this.initialize(element);\n        // return false;\n    }\n\n    preview(element: HTMLCanvasElement | string): boolean {\n        return this.initialize(element);\n        // return false;\n    }\n\n    feature(element: HTMLCanvasElement | string): boolean {\n\n        const success = this.initialize(element);\n\n        const renderer = this._visualization.renderer as Renderer;\n        const canvas = this._canvas as gloperate.Canvas;\n        const visualization = this._visualization;\n\n        const fullscreenTarget = canvas.element;\n\n        window.document.getElementById('fullscreen')!.onclick = () => {\n            gloperate.viewer.Fullscreen.toggle(fullscreenTarget);\n        };\n\n        const loadConfig = (config: Configuration) => {\n            const oldConfig = visualization.configuration;\n\n            try {\n                visualization.configuration = config;\n                visualization.update();\n                renderer.invalidate();\n            }\n            catch (error) {\n                console.log(error);\n\n                if (oldConfig === undefined) {\n                    return;\n                }\n\n                const rescueConfig = new Configuration();\n\n                rescueConfig.topology = oldConfig.topology;\n                rescueConfig.layout = oldConfig.layout;\n                rescueConfig.buffers = oldConfig.buffers;\n                rescueConfig.bufferViews = oldConfig.bufferViews;\n                rescueConfig.colors = oldConfig.colors;\n                rescueConfig.geometry = oldConfig.geometry;\n                rescueConfig.labels = oldConfig.labels;\n\n                visualization.configuration = rescueConfig;\n                visualization.update();\n                renderer.invalidate();\n            }\n        };\n\n        const fileUpload = document.getElementById('fileUpload') as HTMLInputElement;\n        const loadFile = document.getElementById('loadFile') as HTMLInputElement;\n\n        const loadCsv = async () => {\n            const fileList = fileUpload.files;\n            if (fileList === null) return;\n            const file = fileList[0];\n            if (file === undefined) return;\n\n            if (true) {\n                // Papaparse Interface\n                CSVData.loadAsync(file)\n                    .then((config: Configuration) => loadConfig(config));\n            } else {\n                // CBD-Parser Interface\n                CBDData.loadAsync(file)\n                    .then((config: Configuration) => loadConfig(config));\n            }\n        };\n\n        loadFile.onclick = async () => loadCsv();\n\n        // export variables\n\n        (window as any)['gloperate'] = gloperate;\n\n        (window as any)['canvas'] = canvas;\n        (window as any)['context'] = canvas.context;\n        (window as any)['controller'] = canvas.controller;\n\n        (window as any)['visualization'] = visualization;\n        (window as any)['renderer'] = renderer;\n\n        return success;\n    }\n\n\n    initialize(element: HTMLCanvasElement | string): boolean {\n\n        this._canvas = initialize(element);\n\n        this._visualization = new Visualization();\n        const renderer: Renderer = this._visualization.renderer as Renderer;\n        this._canvas.renderer = renderer;\n\n        super.expose();\n\n        return true;\n    }\n\n    uninitialize(): void {\n        this._canvas.dispose();\n        (this._renderer as gloperate.Renderer).uninitialize();\n    }\n}\n","\n        import { ImplicitInnerNodesTreemapFromCSVExample } from './treemap.ts';\n\n        window.onload = function () {\n\n            const canvas = document.getElementById('canvas');\n            const exampleRenderer = new ImplicitInnerNodesTreemapFromCSVExample();\n            window['example'] = exampleRenderer;\n            exampleRenderer.feature(canvas);\n\n            const aboutCode = window.document.getElementById('context-about');\n            if (aboutCode) {\n                aboutCode.innerText = context.aboutString();\n            }\n        };\n    ","\n        import * as treemaprenderer from '/examples/index.ts';\n        window['treemaprenderer'] = treemaprenderer;\n        document.title = __LIB_NAME__;\n        document.querySelector('#version').innerHTML = treemaprenderer.version();\n        document.querySelector('#branch').innerHTML = treemaprenderer.branch();\n        document.querySelector('#commit').innerHTML = treemaprenderer.commit();\n        document.querySelector('#cryear').innerHTML = new Date().getFullYear();\n    "],"names":["log","gloperate.auxiliaries","LogLevel","CSVHeader","_CSVData","header","lines","line","key","value","s","result","config","collect_string_column","name","row","collect_column","column","has_labels_column","paths","pathParts","leafWeights","leafHeights","leafColors","parts","createNode","index","parentIndex","gatherParentKey","edges","names","weights","heights","colors","nodes","currentIndex","partIndex","parentKey","Topology","NodeSort","file","data","payload","resolve","reject","Configuration","parse","error","url","request","CSVData","ImplicitInnerNodesTreemapFromCSVExample","Example","element","success","renderer","canvas","visualization","fullscreenTarget","gloperate.viewer","loadConfig","oldConfig","rescueConfig","fileUpload","loadFile","loadCsv","fileList","gloperate","initialize","Visualization","exampleRenderer","aboutCode","treemaprenderer","treemaprenderer.version","treemaprenderer.branch","treemaprenderer.commit"],"mappings":"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"}