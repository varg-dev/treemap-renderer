{"version":3,"file":"file-CS9xhTmS.js","sources":["../../examples/csv-file-with-implicit-inner-nodes/csvdata.ts","../../node_modules/@hpicgs/cbd-parser/lib/cbd.js","../../examples/csv-file-with-implicit-inner-nodes/cbddata.ts","../../examples/csv-file-with-implicit-inner-nodes/treemap.ts","../../examples/csv-file-with-implicit-inner-nodes/index.html?html-proxy&index=1.js","../../examples/csv-file-with-implicit-inner-nodes/index.html?html-proxy&index=2.js"],"sourcesContent":["\n/* spellchecker: disable */\n\nimport * as gloperate from 'webgl-operate';\n\nimport log = gloperate.auxiliaries.log;\nimport LogLevel = gloperate.auxiliaries.LogLevel;\n\nimport { parse } from 'papaparse';\n\nimport { Configuration, Topology, NodeSort } from '../../source/treemap-renderer';\n\n/* spellchecker: enable */\n\n\nexport class CSVHeader {\n    public csv_delimiter: string;\n    public path_column: string;\n    public weight_column: string;\n    public height_column: string;\n    public color_column: string;\n    public label_column: string;\n    public height_scale: number;\n};\n\nclass Edge {\n    public parentIndex: number;\n    public index: number;\n};\n\n\nexport class CSVData {\n    protected static readonly FAILED = (url: string, request: XMLHttpRequest) =>\n        `fetching '${url}' failed (${request.status}): ${request.statusText}`;\n\n    protected static initializeHeader(header: CSVHeader): void {\n        header.csv_delimiter = ';';\n        header.path_column = 'name';\n    }\n\n    protected static parseHeader(lines: Array<string>, header: CSVHeader): void {\n        while (lines.length >= 1 && lines[0].startsWith('#')) {\n            const line = lines.shift()!.substring(1).trim();\n\n            const [key, value] = line.split('=').map((s: string) => s.trim());\n\n            if (key == 'delimiter') {\n                header.csv_delimiter = value || ';';\n            } else if (key == 'paths') {\n                header.path_column = value || 'name';\n            } else if (key == 'weights') {\n                header.weight_column = value || '';\n            } else if (key == 'heights') {\n                header.height_column = value || '';\n            } else if (key == 'colors') {\n                header.color_column = value || '';\n            } else if (key == 'labels') {\n                header.label_column = value || '';\n            } else if (key == 'heightScale') {\n                header.height_scale = Number.parseFloat(value || '0.1') || 0.1;\n            } else {\n                log(LogLevel.Warning, `Unparsed header`, key, '=', value);\n            }\n        }\n    }\n\n    protected static parsePapaparseResult(result: any, header: CSVHeader, config: Configuration): void {\n        const collect_string_column = (result: any, name: string): Array<string> => {\n            if (result.meta.fields.indexOf(name) < 0) {\n                const column = new Array<string>(result.data.length);\n                return column;\n            }\n\n            const column = (result.data as Array<string>).map((row: any) => {\n                return row[name] ? row[name] : \"\";\n            });\n\n            return column;\n        };\n\n        const collect_column = (result: any, name: string) => {\n            if (result.meta.fields.indexOf(name) < 0) {\n                const column = new Array(result.data.length);\n                column.fill(-1);\n                return column;\n            }\n\n            const column = result.data.map((row: any) => {\n                return row[name] ? parseFloat(row[name]) : -1.0;\n            });\n\n            return column;\n        };\n\n        const has_labels_column = (name: string) => result.meta.fields.indexOf(name) >= 0;\n\n        // parse edges\n\n        const paths = collect_string_column(result, header.path_column);\n        for (let i = 0; i < paths.length; ++i) {\n            paths[i] = paths[i].replace(\"./\", \"\");\n        }\n        const pathParts = paths.map((value: string) => value.split('/'));\n\n        // parse weights\n\n        const leafWeights = collect_column(result, header.weight_column);\n\n        // parse heights\n\n        const leafHeights = collect_column(result, header.height_column);\n\n        // parse colors\n\n        const leafColors = collect_column(result, header.color_column);\n\n        // parse labels\n\n        const labels = has_labels_column(header.label_column) ?\n            collect_string_column(result, header.label_column) :\n            pathParts.map((parts: string[]) => parts.at(-1));\n\n        // Load topology\n\n        const createNode = (index: number, parentIndex: number): Edge => {\n            return { parentIndex, index } as Edge;\n        };\n\n        const gatherParentKey = (parts: string[], index: number): string => {\n            return \"/\" + parts.slice(0, index).join('/');\n        }\n\n        const edges = new Array<Configuration.NodeIdentifier>();\n        const names = new Map<number, string>();\n        const weights = new Array<number>();\n        const heights = new Array<number>();\n        const colors = new Array<number>();\n\n        const nodes = {};\n        let currentIndex = -1;\n\n        // Create root\n        nodes['/'] = createNode(currentIndex, -1);\n        currentIndex += 1;\n        weights.push(0);\n        heights.push(0);\n        colors.push(0);\n\n        // Create inner nodes and leaf nodes\n        pathParts.forEach((parts: Array<string>, partIndex: number) => {\n            parts.forEach((value: string, index: number) => {\n                const parentKey = gatherParentKey(parts, index);\n                const key = gatherParentKey(parts, index + 1);\n\n                if (!(parentKey in nodes)) {\n                    log(LogLevel.Warning, parentKey, 'not in', nodes);\n                    return;\n                }\n\n                if (key in nodes) {\n                    // Inner node already created\n                    return;\n                }\n\n                nodes[key] = createNode(currentIndex, nodes[parentKey].index);\n                edges.push(nodes[key].parentIndex);\n                edges.push(currentIndex);\n                names.set(currentIndex, value);\n                currentIndex += 1;\n\n                if (index == parts.length - 1) {\n                    // Is leaf node\n                    weights.push(leafWeights[partIndex]);\n                    heights.push(leafHeights[partIndex]);\n                    colors.push(leafColors[partIndex]);\n                } else {\n                    // Is inner node\n                    weights.push(0);\n                    heights.push(0);\n                    colors.push(0);\n                }\n            });\n        });\n\n        config.topology = {\n            edges: edges,\n            semantics: Topology.InputSemantics.ParentIdId,\n            format: Topology.InputFormat.Interleaved,\n        };\n\n        config.buffers = [\n            {\n                identifier: 'source-weights',\n                type: 'numbers',\n                data: weights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-heights',\n                type: 'numbers',\n                data: heights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-colors',\n                type: 'numbers',\n                data: colors,\n                linearization: 'topology',\n            }\n        ];\n\n        config.bufferViews = [\n            {\n                identifier: 'weights',\n                source: 'buffer:source-weights',\n                transformations: [\n                    { type: 'fill-invalid', value: 1.0, invalidValue: -1.0 },\n                    { type: 'propagate-up', operation: 'sum' }\n                ],\n            },\n            {\n                identifier: 'heights-normalized',\n                source: 'buffer:source-heights',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' }\n                ],\n            },\n            {\n                identifier: 'colors-normalized',\n                source: 'buffer:source-colors',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' }\n                ],\n            }\n        ];\n\n        config.colors = [\n            { identifier: 'emphasis', colorspace: 'hex', value: '#00b0ff' },\n            { identifier: 'auxiliary', colorspace: 'hex', values: ['#00aa5e', '#71237c'] },\n            { identifier: 'inner', colorspace: 'hex', values: ['#e8eaee', '#eef0f4'] },\n            { identifier: 'leaf', preset: 'Greens', steps: 7 },\n        ];\n\n        config.layout = {\n            algorithm: 'snake',\n            weight: 'bufferView:weights',\n            sort: {\n                key: 'bufferView:weights',\n                algorithm: NodeSort.Algorithm.Keep\n            },\n            parentPadding: { type: 'relative', value: 0.05 },\n            siblingMargin: { type: 'relative', value: 0.05 },\n            accessoryPadding: {\n                type: 'absolute',\n                direction: 'bottom',\n                value: [0.0, 0.02, 0.01, 0.0],\n                relativeAreaThreshold: 0.4, targetAspectRatio: 8.0,\n            },\n        };\n\n        config.geometry = {\n            parentLayer: { showRoot: false },\n            leafLayer: {\n                colorMap: 'color:leaf',\n                height: 'bufferView:heights-normalized',\n                colors: 'bufferView:colors-normalized',\n            },\n            emphasis: { outline: new Array<number>(), highlight: new Array<number>() },\n            heightScale: header.height_scale,\n        };\n\n        config.labels = {\n            innerNodeLayerRange: [1, 2],\n            numTopInnerNodes: 50,\n            numTopWeightNodes: 50,\n            numTopHeightNodes: 50,\n            numTopColorNodes: 50,\n            names: names,\n        };\n\n        config.altered.alter('any');\n    }\n\n    static async loadAsync(file: File): Promise<Configuration> {\n        const data = await file.text();\n\n        const header = new CSVHeader();\n\n        CSVData.initializeHeader(header);\n\n        const lines = data.split('\\n');\n\n        CSVData.parseHeader(lines, header);\n\n        const payload = lines.join('\\n');\n\n        return this.loadAsyncHeader(payload, header);\n    }\n\n    static loadAsyncHeader(data: string, header: CSVHeader): Promise<Configuration> {\n        return new Promise<Configuration>((resolve, reject) => {\n            const config = new Configuration();\n\n            parse(data, {\n                error: (error: any) => reject(error),\n                complete: (result) => {\n                    CSVData.parsePapaparseResult(result, header, config);\n\n                    resolve(config);\n                },\n                delimiter: header.csv_delimiter,\n                quoteChar: '\"',\n                escapeChar: '\"',\n                header: true,\n                comments: '#',\n                skipEmptyLines: true\n            });\n        });\n    }\n\n}\n","class GoogleCsvTransformer {\n  constructor() {\n    this._isInValues = false;\n    this._isInRow = false;\n    this._resultChunk = \"\";\n    this.transform = (chunk, controller) => {\n      const searchString = `\"values\": [`;\n      const rows = chunk.split(\"\\n\");\n      let start = 0;\n      if (!this._isInValues) {\n        if (chunk.includes(searchString)) {\n          this._isInValues = true;\n          start = rows.findIndex((row) => row.trim() === searchString) + 1;\n        } else {\n          return;\n        }\n      }\n      for (const row of rows.slice(start)) {\n        const value = row.trim();\n        switch (value) {\n          case \"[\":\n            this._isInRow = true;\n            break;\n          case \"],\":\n          case \"]\":\n            if (!this._isInRow) {\n              controller.enqueue(this._resultChunk);\n              controller.terminate();\n              return;\n            }\n            this._resultChunk += \"\\n\";\n            this._isInRow = false;\n            break;\n          default:\n            this._resultChunk += value.replace(/\"/g, \"\");\n            break;\n        }\n      }\n      controller.enqueue(this._resultChunk);\n      this._resultChunk = \"\";\n    };\n  }\n  start() {\n  }\n  flush() {\n  }\n}\nfunction calculateEndColumn(columnCount) {\n  const A = \"A\".charCodeAt(0);\n  let columnName = \"\";\n  while (columnCount > 0) {\n    const mod = (columnCount - 1) % 26;\n    columnName = String.fromCharCode(A + mod) + columnName;\n    columnCount = Math.trunc((columnCount - mod) / 26);\n  }\n  return columnName;\n}\nfunction fetchSheetData$1(route) {\n  return fetch(`https://sheets.googleapis.com/v4/spreadsheets${route}`);\n}\nasync function fetchSheetDataRange$1(sheetId, apiKey) {\n  const route = `/${sheetId}?key=${apiKey}`;\n  const response = await fetchSheetData$1(route);\n  const { sheets } = await response.json();\n  const {\n    title,\n    gridProperties: { rowCount, columnCount }\n  } = sheets[0].properties;\n  const range = `${title}!A1:${calculateEndColumn(columnCount)}${rowCount}`;\n  return range;\n}\nasync function fetchSheetValues$1(sheetId, apiKey, range) {\n  const route = `/${sheetId}/values/${range}?key=${apiKey}`;\n  const response = await fetchSheetData$1(route);\n  const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream(new GoogleCsvTransformer())).pipeThrough(new TextEncoderStream());\n  return stream;\n}\nvar google = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  fetchSheetDataRange: fetchSheetDataRange$1,\n  fetchSheetValues: fetchSheetValues$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nclass ExcelCsvTransformer {\n  constructor() {\n    this._isInValues = false;\n    this._isInRow = false;\n    this._resultChunk = \"\";\n    this.transform = (chunk, controller) => {\n      const searchString = `\"text\":[`;\n      let start = 0;\n      if (!this._isInValues) {\n        const searchIndex = chunk.indexOf(searchString);\n        if (searchIndex >= 0) {\n          this._isInValues = true;\n          start = searchIndex + searchString.length;\n        } else {\n          return;\n        }\n      }\n      for (const char of chunk.substring(start)) {\n        switch (char) {\n          case \"[\":\n            this._isInRow = true;\n            break;\n          case \"]\":\n            if (!this._isInRow) {\n              controller.enqueue(this._resultChunk);\n              controller.terminate();\n              return;\n            }\n            this._resultChunk += \"\\n\";\n            this._isInRow = false;\n            break;\n          case '\"':\n            break;\n          case \",\":\n            if (!this._isInRow) {\n              break;\n            }\n          default:\n            this._resultChunk += char;\n            break;\n        }\n      }\n      controller.enqueue(this._resultChunk);\n      this._resultChunk = \"\";\n    };\n  }\n  start() {\n  }\n  flush() {\n  }\n}\nfunction fetchSheetData(route, apiToken) {\n  const headers = new Headers();\n  headers.set(\"Authorization\", `Bearer ${apiToken}`);\n  return fetch(`https://graph.microsoft.com/v1.0/me/drive/items${route}`, { headers });\n}\nasync function fetchSheetDataRange(sheetId, apiToken) {\n  const route = `/${sheetId}/workbook/worksheets`;\n  const response = await fetchSheetData(route, apiToken);\n  const { value: sheets } = await response.json();\n  const { name } = sheets[0];\n  return name;\n}\nasync function fetchSheetValues(sheetId, apiToken, tableName) {\n  const route = `/${sheetId}/workbook/worksheets('${tableName}')/usedRange?$select=text`;\n  const response = await fetchSheetData(route, apiToken);\n  const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream(new ExcelCsvTransformer())).pipeThrough(new TextEncoderStream());\n  return stream;\n}\nvar excel = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  fetchSheetDataRange,\n  fetchSheetValues\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction parseSheetId(sheetUrl) {\n  const url = new URL(sheetUrl);\n  let type;\n  let sheetId;\n  switch (url.host) {\n    case \"docs.google.com\":\n      type = \"google\";\n      [, , , sheetId] = url.pathname.split(\"/\");\n      break;\n    case \"onedrive.live.com\":\n      type = \"excel\";\n      sheetId = url.searchParams.get(\"resid\");\n      break;\n    default:\n      throw new Error(\"Invalid url for spreadsheet service\");\n  }\n  return { type, sheetId };\n}\nvar DataType = /* @__PURE__ */ ((DataType2) => {\n  DataType2[\"Number\"] = \"number\";\n  DataType2[\"Int8\"] = \"int8\";\n  DataType2[\"Uint8\"] = \"uint8\";\n  DataType2[\"Int16\"] = \"int16\";\n  DataType2[\"Uint16\"] = \"uint16\";\n  DataType2[\"Int32\"] = \"int32\";\n  DataType2[\"Uint32\"] = \"uint32\";\n  DataType2[\"Float32\"] = \"float32\";\n  DataType2[\"Float64\"] = \"float64\";\n  DataType2[\"Color\"] = \"color\";\n  DataType2[\"String\"] = \"string\";\n  DataType2[\"Date\"] = \"date\";\n  return DataType2;\n})(DataType || {});\nfunction bytes(type) {\n  switch (type) {\n    case \"int8\":\n    case \"uint8\":\n      return 1;\n    case \"int16\":\n    case \"uint16\":\n      return 2;\n    case \"int32\":\n    case \"uint32\":\n    case \"float32\":\n    case \"number\":\n      return 4;\n    case \"float64\":\n    case \"date\":\n      return 8;\n    case \"color\":\n      return 16;\n    case \"string\":\n    default:\n      return 0;\n  }\n}\nfunction isFloat(type) {\n  switch (type) {\n    case \"number\":\n    case \"float32\":\n    case \"float64\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isInt(type) {\n  switch (type) {\n    case \"int8\":\n    case \"uint8\":\n    case \"int16\":\n    case \"uint16\":\n    case \"int32\":\n    case \"uint32\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isNumber(type) {\n  switch (type) {\n    case \"number\":\n    case \"int8\":\n    case \"uint8\":\n    case \"int16\":\n    case \"uint16\":\n    case \"int32\":\n    case \"uint32\":\n    case \"float32\":\n    case \"float64\":\n      return true;\n    default:\n      return false;\n  }\n}\nconst DEFAULT_ALPHA = 1;\nconst HEX_FORMAT_REGEX = new RegExp(/^(#|0x)?(([0-9a-f]{3}){1,2}|([0-9a-f]{4}){1,2})$/i);\nfunction hex2rgba(hex, failSilent = false) {\n  const rgba = [0, 0, 0, DEFAULT_ALPHA];\n  if (!HEX_FORMAT_REGEX.test(hex)) {\n    if (!failSilent) {\n      console.warn(\n        \"hexadecimal RGBA color string must conform to either\",\n        \"#0000, or #00000000, given\",\n        hex\n      );\n    }\n    return rgba;\n  }\n  const offset = hex.startsWith(\"0x\") ? 2 : hex.startsWith(\"#\") ? 1 : 0;\n  const length = Math.floor((hex.length - offset) / 3);\n  const stride = length - 1;\n  rgba[0] = parseInt(hex[offset + 0 * length] + hex[offset + 0 * length + stride], 16) / 255;\n  rgba[1] = parseInt(hex[offset + 1 * length] + hex[offset + 1 * length + stride], 16) / 255;\n  rgba[2] = parseInt(hex[offset + 2 * length] + hex[offset + 2 * length + stride], 16) / 255;\n  if (hex.length - offset === 4 || hex.length - offset === 8) {\n    rgba[3] = parseInt(hex[offset + 3 * length] + hex[offset + 3 * length + stride], 16) / 255;\n  }\n  if (!failSilent && (isNaN(rgba[0]) || isNaN(rgba[1]) || isNaN(rgba[2]) || isNaN(rgba[3]))) {\n    console.warn(`expected well formatted hexadecimal RGBA string, given '${hex}'`);\n  }\n  return rgba;\n}\nfunction inferType(input) {\n  if (input.startsWith(\"#\")) {\n    const col = hex2rgba(input, true);\n    if (col[0] !== 0 || col[1] !== 0 || col[2] !== 0 || col[3] !== 0) {\n      return DataType.Color;\n    }\n  }\n  if (!Number.isNaN(Number(input))) {\n    return DataType.Number;\n  }\n  if (!isNaN(Date.parse(input))) {\n    return DataType.Date;\n  }\n  return DataType.String;\n}\nfunction lowestType(a, b) {\n  if (a === void 0)\n    return b;\n  if (b === void 0)\n    return a;\n  const set = /* @__PURE__ */ new Set([a, b]);\n  if (set.size === 1)\n    return set.values().next().value;\n  if (set.has(DataType.Date) && set.has(DataType.Number))\n    return DataType.Date;\n  return DataType.String;\n}\nfunction splitLines(chunk, lines, remainder = \"\") {\n  let start = 0;\n  let newLine;\n  while ((newLine = chunk.indexOf(\"\\n\", start)) !== -1) {\n    const hasReturn = chunk.charAt(newLine - 1) === \"\\r\";\n    const str = chunk.substring(start, newLine - (hasReturn ? 1 : 0));\n    if (start === 0) {\n      lines.push(remainder + str);\n    } else {\n      lines.push(str);\n    }\n    start = newLine + 1;\n  }\n  return chunk.substring(start);\n}\nfunction parse(chunks, start, end) {\n  if (start.chunk === end.chunk) {\n    return parseSingleChunk(chunks[start.chunk], start, end);\n  }\n  return parseMultipleChunks(chunks, start, end);\n}\nfunction parseSingleChunk(chunk, start, end) {\n  const decoder = new TextDecoder();\n  const lines = new Array();\n  const buffer2 = new Uint8Array(chunk, start.char, end.char - start.char);\n  const remainder = splitLines(decoder.decode(buffer2), lines);\n  lines.push(remainder);\n  return lines;\n}\nfunction parseMultipleChunks(chunks, start, end) {\n  const decoder = new TextDecoder();\n  const expectMore = { stream: true };\n  const lines = new Array();\n  let remainder = \"\";\n  const first = new Uint8Array(chunks[start.chunk], start.char);\n  remainder = splitLines(decoder.decode(first, expectMore), lines, remainder);\n  for (let i = start.chunk + 1; i < end.chunk; i++) {\n    remainder = splitLines(decoder.decode(chunks[i], expectMore), lines, remainder);\n  }\n  const last = new Uint8Array(chunks[end.chunk], 0, end.char);\n  remainder = splitLines(decoder.decode(last), lines, remainder);\n  lines.push(remainder);\n  return lines;\n}\nclass PerfMon {\n  constructor() {\n    this._samples = /* @__PURE__ */ new Map();\n  }\n  start(id, label = id.toString()) {\n    if (this._samples.has(id)) {\n      console.warn(\"performance measurement already exists\");\n      return;\n    }\n    this._samples.set(id, {\n      start: Date.now(),\n      end: 0,\n      delta: 0,\n      label\n    });\n  }\n  stop(id) {\n    if (!this._samples.has(id)) {\n      console.warn(\"performance measurement doesn't exist\");\n      return;\n    }\n    const sample = this._samples.get(id);\n    sample.end = Date.now();\n    sample.delta = sample.end - sample.start;\n  }\n  get samples() {\n    return [...this._samples.values()];\n  }\n}\nfunction splitLine(line, delimiter) {\n  const cells = new Array();\n  let start = 0;\n  let quote = false;\n  let quoteActive = false;\n  const push = (end) => {\n    cells.push(line.substring(quote ? start + 1 : start, quote ? end - 1 : end));\n  };\n  for (let i = 0; i < line.length; i++) {\n    const char = line.charAt(i);\n    if (char === '\"') {\n      quoteActive = !quoteActive;\n      quote = true;\n      continue;\n    }\n    if (quoteActive) {\n      continue;\n    }\n    const { end, skip } = cellEnd(line, i, delimiter);\n    if (end) {\n      push(i);\n      start = i + skip;\n      quote = false;\n    }\n  }\n  push(void 0);\n  return cells;\n}\nfunction cellEnd(line, index, delimiter) {\n  const char = line.charAt(index);\n  switch (char) {\n    case delimiter:\n    case \"\\n\":\n      return { end: true, skip: 1 };\n    case \"\\r\":\n      if (line.charAt(index + 1) === \"\\n\") {\n        return { end: true, skip: 2 };\n      }\n    default:\n      return { end: false, skip: 0 };\n  }\n}\nfunction buffer(length, shared) {\n  if (shared)\n    return new SharedArrayBuffer(length);\n  else\n    return new ArrayBuffer(length);\n}\nclass BaseChunk {\n  constructor(type, length, offset) {\n    this._type = type;\n    this._length = length;\n    this._offset = offset;\n  }\n  get type() {\n    return this._type;\n  }\n  get length() {\n    return this._length;\n  }\n  get offset() {\n    return this._offset;\n  }\n  set offset(offset) {\n    this._offset = offset;\n  }\n}\nclass BufferChunk extends BaseChunk {\n  get data() {\n    return this._data;\n  }\n}\nclass ColorChunk extends BufferChunk {\n  constructor(length, offset, shared) {\n    super(DataType.Color, length, offset);\n    this._data = buffer(length * 4 * 4, shared);\n    this._view = new Float32Array(this._data);\n  }\n  get view() {\n    return this._view;\n  }\n  get(index) {\n    return Array.from(this._view.subarray(index * 4, (index + 1) * 4));\n  }\n  set(index, value) {\n    this._view.set(value, index * 4);\n  }\n}\nclass DateChunk extends BufferChunk {\n  constructor(length, offset, shared) {\n    super(DataType.Date, length, offset);\n    this._data = buffer(length * bytes(DataType.Date), shared);\n    this._view = new Float64Array(this._data);\n    this._min = Number.POSITIVE_INFINITY;\n    this._max = Number.NEGATIVE_INFINITY;\n  }\n  get view() {\n    return this._view;\n  }\n  get rawMin() {\n    return this._min;\n  }\n  get rawMax() {\n    return this._max;\n  }\n  get min() {\n    return new Date(this._min);\n  }\n  get max() {\n    return new Date(this._max);\n  }\n  updateExtrema(value) {\n    if (value < this._min)\n      this._min = value;\n    if (value > this._max)\n      this._max = value;\n  }\n  rawGet(index) {\n    return this._view[index];\n  }\n  rawSet(index, value) {\n    this._view[index] = value;\n    this.updateExtrema(value);\n  }\n  get(index) {\n    return new Date(this._view[index]);\n  }\n  set(index, value) {\n    const time = value.getTime();\n    this._view[index] = time;\n    this.updateExtrema(time);\n  }\n}\nclass BaseNumberChunk extends BufferChunk {\n  constructor(length, offset, bytes2, shared) {\n    super(DataType.Number, length, offset);\n    this._data = buffer(length * bytes2, shared);\n    this._min = Number.POSITIVE_INFINITY;\n    this._max = Number.NEGATIVE_INFINITY;\n  }\n  get view() {\n    return this._view;\n  }\n  get min() {\n    return this._min;\n  }\n  get max() {\n    return this._max;\n  }\n  get(index) {\n    return this._view[index];\n  }\n  set(index, value) {\n    this._view[index] = value;\n    if (value < this._min)\n      this._min = value;\n    if (value > this._max)\n      this._max = value;\n  }\n}\nclass Int8Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Int8), shared);\n    this._view = new Int8Array(this._data);\n  }\n}\nclass Uint8Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Uint8), shared);\n    this._view = new Uint8Array(this._data);\n  }\n}\nclass Int16Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Int16), shared);\n    this._view = new Int16Array(this._data);\n  }\n}\nclass Uint16Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Uint16), shared);\n    this._view = new Uint16Array(this._data);\n  }\n}\nclass Int32Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Int32), shared);\n    this._view = new Int32Array(this._data);\n  }\n}\nclass Uint32Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Uint32), shared);\n    this._view = new Uint32Array(this._data);\n  }\n}\nclass Float32Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Float32), shared);\n    this._view = new Float32Array(this._data);\n  }\n}\nclass Float64Chunk extends BaseNumberChunk {\n  constructor(length, offset, shared) {\n    super(length, offset, bytes(DataType.Float64), shared);\n    this._view = new Float64Array(this._data);\n  }\n}\nclass StringChunk extends BaseChunk {\n  constructor(length, offset, shared) {\n    super(DataType.String, length, offset);\n    this._data = new Array(length);\n  }\n  get(index) {\n    return this._data[index];\n  }\n  set(index, value) {\n    this._data[index] = value;\n  }\n}\nfunction buildChunk(type, length, offset, shared) {\n  switch (type) {\n    case DataType.Number:\n    case DataType.Float32:\n      return new Float32Chunk(length, offset, shared);\n    case DataType.Int8:\n      return new Int8Chunk(length, offset, shared);\n    case DataType.Uint8:\n      return new Uint8Chunk(length, offset, shared);\n    case DataType.Int16:\n      return new Int16Chunk(length, offset, shared);\n    case DataType.Uint16:\n      return new Uint16Chunk(length, offset, shared);\n    case DataType.Int32:\n      return new Int32Chunk(length, offset, shared);\n    case DataType.Uint32:\n      return new Uint32Chunk(length, offset, shared);\n    case DataType.Float64:\n      return new Float64Chunk(length, offset, shared);\n    case DataType.Color:\n      return new ColorChunk(length, offset, shared);\n    case DataType.Date:\n      return new DateChunk(length, offset, shared);\n    case DataType.String:\n      return new StringChunk(length, offset, shared);\n    default:\n      return void 0;\n  }\n}\nfunction rebuildChunk(chunk, shared) {\n  const oc = chunk;\n  const nc = buildChunk(oc._type, 0, 0, shared);\n  return Object.assign(nc, chunk);\n}\nclass BaseColumn {\n  constructor(name, type) {\n    this._chunks = [];\n    this._length = 0;\n    this._name = name;\n    this._type = type;\n  }\n  push(chunk) {\n    this._chunks.push(chunk);\n    this._length += chunk.length;\n    this._altered = true;\n  }\n  reset() {\n    this._chunks = [];\n    this._length = 0;\n    this._altered = true;\n  }\n  get name() {\n    return this._name;\n  }\n  get type() {\n    return this._type;\n  }\n  get length() {\n    return this._length;\n  }\n  get(index) {\n    const chunk = this._chunks.find((c) => c.offset <= index && c.offset + c.length > index);\n    if (!chunk)\n      throw new Error(\"Invalid index.\");\n    return chunk.get(index - chunk.offset);\n  }\n  set(index, value) {\n    const chunk = this._chunks.find((c) => c.offset <= index && c.offset + c.length > index);\n    if (!chunk)\n      throw new Error(\"Invalid index.\");\n    chunk.set(index - chunk.offset, value);\n  }\n  get chunkCount() {\n    return this._chunks.length;\n  }\n  get chunks() {\n    return this._chunks;\n  }\n  getChunk(index) {\n    return this._chunks[index];\n  }\n  getChunks(start = 0, end) {\n    return this._chunks.slice(start, end);\n  }\n  get altered() {\n    return this._altered;\n  }\n  set altered(altered) {\n    this._altered = altered;\n  }\n}\nclass ColorColumn extends BaseColumn {\n  constructor(name) {\n    super(name, DataType.Color);\n  }\n}\nclass DateColumn extends BaseColumn {\n  constructor(name) {\n    super(name, DataType.Date);\n    this._min = Number.POSITIVE_INFINITY;\n    this._max = Number.NEGATIVE_INFINITY;\n  }\n  push(chunk) {\n    super.push(chunk);\n    if (chunk.rawMin < this._min)\n      this._min = chunk.rawMin;\n    if (chunk.rawMax > this._max)\n      this._max = chunk.rawMax;\n  }\n  reset() {\n    super.reset();\n    this._min = Number.POSITIVE_INFINITY;\n    this._max = Number.NEGATIVE_INFINITY;\n  }\n  get rawMin() {\n    return this._min;\n  }\n  get rawMax() {\n    return this._max;\n  }\n  get min() {\n    return new Date(this._min);\n  }\n  get max() {\n    return new Date(this._max);\n  }\n}\nclass BaseNumberColumn extends BaseColumn {\n  constructor(name) {\n    super(name, DataType.Number);\n    this._min = Number.POSITIVE_INFINITY;\n    this._max = Number.NEGATIVE_INFINITY;\n  }\n  push(chunk) {\n    super.push(chunk);\n    if (chunk.min < this._min)\n      this._min = chunk.min;\n    if (chunk.max > this._max)\n      this._max = chunk.max;\n  }\n  reset() {\n    super.reset();\n    this._min = Number.POSITIVE_INFINITY;\n    this._max = Number.NEGATIVE_INFINITY;\n  }\n  get min() {\n    return this._min;\n  }\n  get max() {\n    return this._max;\n  }\n}\nclass Int8Column extends BaseNumberColumn {\n}\nclass Uint8Column extends BaseNumberColumn {\n}\nclass Int16Column extends BaseNumberColumn {\n}\nclass Uint16Column extends BaseNumberColumn {\n}\nclass Int32Column extends BaseNumberColumn {\n}\nclass Uint32Column extends BaseNumberColumn {\n}\nclass Float32Column extends BaseNumberColumn {\n}\nclass Float64Column extends BaseNumberColumn {\n}\nclass StringColumn extends BaseColumn {\n  constructor(name) {\n    super(name, DataType.String);\n  }\n}\nfunction buildColumn(name, type) {\n  switch (type) {\n    case DataType.Number:\n    case DataType.Float32:\n      return new Float32Column(name);\n    case DataType.Int8:\n      return new Int8Column(name);\n    case DataType.Uint8:\n      return new Uint8Column(name);\n    case DataType.Int16:\n      return new Int16Column(name);\n    case DataType.Uint16:\n      return new Uint16Column(name);\n    case DataType.Int32:\n      return new Int32Column(name);\n    case DataType.Uint32:\n      return new Uint32Column(name);\n    case DataType.Float64:\n      return new Float64Column(name);\n    case DataType.Color:\n      return new ColorColumn(name);\n    case DataType.Date:\n      return new DateColumn(name);\n    case DataType.String:\n      return new StringColumn(name);\n    default:\n      return void 0;\n  }\n}\nfunction rebuildColumn(column, shared) {\n  const oldColumn = column;\n  const newColumn = buildColumn(oldColumn._name, oldColumn._type);\n  Object.assign(newColumn, column);\n  newColumn.chunks.forEach((chunk, index, chunks) => {\n    chunks[index] = rebuildChunk(chunk, shared);\n  });\n  return newColumn;\n}\nvar MessageType = /* @__PURE__ */ ((MessageType2) => {\n  MessageType2[MessageType2[\"Setup\"] = 0] = \"Setup\";\n  MessageType2[MessageType2[\"AddChunk\"] = 1] = \"AddChunk\";\n  MessageType2[MessageType2[\"NoMoreChunks\"] = 2] = \"NoMoreChunks\";\n  MessageType2[MessageType2[\"Processed\"] = 3] = \"Processed\";\n  MessageType2[MessageType2[\"Finished\"] = 4] = \"Finished\";\n  return MessageType2;\n})(MessageType || {});\nclass Loader {\n  constructor() {\n    this._perfMon = new PerfMon();\n  }\n  openStream(result) {\n    if (!result.value) {\n      if (this._options.verbose)\n        console.log(\"received no data\");\n      throw new Error(\"No data\");\n    }\n    this._firstChunk = result.value.buffer;\n    return this.detectTypes(result.value);\n  }\n  async readStreamFirstChunk() {\n    const acd = {\n      chunk: this._firstChunk\n    };\n    const msg = {\n      type: MessageType.AddChunk,\n      data: acd\n    };\n    this._worker.postMessage(msg, [this._firstChunk]);\n    this._firstChunk = void 0;\n    const result = await this._reader.read();\n    await this.readStream(result);\n  }\n  async readStream(result) {\n    if (result.done) {\n      if (this._options.verbose)\n        console.log(\"stream ended\");\n      this.sendNoMoreChunks();\n      return;\n    }\n    if (!result.value) {\n      if (this._options.verbose)\n        console.log(\"received no data\");\n      throw new Error(\"No data\");\n    }\n    const acd = {\n      chunk: result.value.buffer\n    };\n    const msg = {\n      type: MessageType.AddChunk,\n      data: acd\n    };\n    this._worker.postMessage(msg, [result.value.buffer]);\n    const nextResult = await this._reader.read();\n    await this.readStream(nextResult);\n  }\n  openBuffer() {\n    return this.detectTypes(this._buffer);\n  }\n  readBuffer() {\n    this._worker.postMessage(\n      {\n        type: MessageType.AddChunk,\n        data: { chunk: this._buffer }\n      },\n      [this._buffer]\n    );\n    this._worker.postMessage({\n      type: MessageType.NoMoreChunks,\n      data: {}\n    });\n  }\n  sendNoMoreChunks() {\n    const data = {};\n    const msg = {\n      type: MessageType.NoMoreChunks,\n      data\n    };\n    this._worker.postMessage(msg);\n  }\n  detectTypes(chunk) {\n    const lines = parse([chunk], { chunk: 0, char: 0 }, { chunk: 0, char: chunk.byteLength });\n    this._firstChunkSplit = lines.map((l) => splitLine(l, this._options.delimiter));\n    const inferStart = +this._options.includesHeader;\n    const inferLines = this._firstChunkSplit.slice(\n      inferStart,\n      Math.min(\n        inferStart + this._options.typeInferLines,\n        this._firstChunkSplit.length - 1\n      )\n    );\n    const detectedTypes = inferLines.map((lines2) => lines2.map((columns) => inferType(columns))).reduce((prev, cur) => prev.map((type, index) => lowestType(type, cur[index])));\n    const headers = detectedTypes.map((type, index) => ({\n      name: this._options.includesHeader ? this._firstChunkSplit[0][index] : \"\",\n      type\n    }));\n    this._perfMon.stop(`${this._openedSourceId}-open`);\n    return headers;\n  }\n  setupColumns() {\n    this._columns = [\n      ...this._loadOptions.columns.map(\n        ({ type }, index) => buildColumn(\n          this._options.includesHeader ? this._firstChunkSplit[0][index] : `Column ${index}`,\n          type\n        )\n      ),\n      ...(this._loadOptions.generatedColumns ?? []).map(\n        ({ name, type }) => buildColumn(name, type)\n      )\n    ];\n    this._firstChunkSplit = void 0;\n    return this._columns;\n  }\n  setupWorker() {\n    return new Promise((resolve, reject) => {\n      this._worker = new Worker(\n        new URL(\"main.js\", import.meta.url),\n        { type: \"module\" }\n      );\n      this._worker.onmessage = (event) => {\n        const message2 = event.data;\n        switch (message2.type) {\n          case MessageType.Processed: {\n            const progress = this.onProcessed(message2.data);\n            this._loadOptions.onUpdate?.(progress);\n            break;\n          }\n          case MessageType.Finished: {\n            this._worker.terminate();\n            resolve(this.onFinished(message2.data));\n            break;\n          }\n          default: {\n            if (this._options.verbose)\n              console.log(\"received invalid msg from main worker:\", message2);\n            reject([\"received invalid msg from main worker:\", message2]);\n            break;\n          }\n        }\n      };\n      const setup = {\n        columns: this._loadOptions.columns.map((column) => column.type),\n        generatedColumns: this._loadOptions.generatedColumns ?? [],\n        options: {\n          delimiter: this._options.delimiter,\n          includesHeader: this._options.includesHeader,\n          verbose: this._options.verbose\n        }\n      };\n      const message = {\n        type: MessageType.Setup,\n        data: setup\n      };\n      this._worker.postMessage(message);\n    });\n  }\n  onProcessed(data) {\n    const chunks = data.chunks.map(\n      (chunk) => rebuildChunk(chunk, this._options.sharedArrayBuffer)\n    );\n    chunks.forEach((chunk, index) => this._columns[index]?.push(chunk));\n    return this._columns[0].length;\n  }\n  onFinished(data) {\n    if (this._options.verbose)\n      console.log(\"main worker finished\");\n    this._perfMon.stop(`${this._openedSourceId}-load`);\n    data.performance = [...this._perfMon.samples, ...data.performance];\n    this._buffer = null;\n    this._stream = null;\n    this._openedSourceId = null;\n    return data;\n  }\n  fakeSubWorkerReference() {\n    new Worker(\n      new URL(\"sub.js\", import.meta.url),\n      { type: \"module\" }\n    );\n  }\n  async open(id) {\n    if (this._options.delimiter === void 0) {\n      throw new Error(\"Delimiter not specified nor deductible from filename.\");\n    }\n    this._openedSourceId = id;\n    this._perfMon.start(`${id}-open`);\n    if (this._stream) {\n      this._reader = this._stream.getReader();\n      const result = await this._reader.read();\n      return this.openStream(result);\n    } else {\n      return this.openBuffer();\n    }\n  }\n  async load() {\n    this._perfMon.start(`${this._openedSourceId}-load`);\n    const columns = this.setupColumns();\n    this._loadOptions.onInit?.(columns);\n    const statistics = this.setupWorker();\n    if (this._stream) {\n      this.readStreamFirstChunk();\n    } else {\n      this.readBuffer();\n    }\n    return { columns, statistics: await statistics };\n  }\n  set stream(stream) {\n    this._stream = stream;\n  }\n  set buffer(buffer2) {\n    this._buffer = buffer2;\n  }\n  set options(options) {\n    this._options = options;\n    if (options.sharedArrayBuffer && !SharedArrayBuffer) {\n      console.error(\"Shared buffer requested, but not available!\");\n      this._options = Object.assign({}, options, { sharedArrayBuffer: false });\n    }\n  }\n  set loadOptions(options) {\n    this._loadOptions = options;\n  }\n}\nLoader.TargetNumWorkers = 25;\nfunction createDataSources(sources) {\n  return sources;\n}\nclass CSV {\n  constructor(options) {\n    this._options = {\n      dataSources: {},\n      includesHeader: true,\n      typeInferLines: 20,\n      verbose: false,\n      ...options\n    };\n    this._loader = new Loader();\n  }\n  openFile(file) {\n    var _a, _b;\n    (_a = this._options).size ?? (_a.size = file.size);\n    if (file instanceof File) {\n      (_b = this._options).delimiter ?? (_b.delimiter = deductDelimiter(file.name.split(\".\").pop()));\n    }\n    this._loader.options = this._options;\n    this._loader.stream = file.stream();\n    return this._loader.open(this._openedDataSource);\n  }\n  async openUrl(url) {\n    var _a, _b;\n    (_a = this._options).delimiter ?? (_a.delimiter = deductDelimiter(url.split(\".\").pop()));\n    const size = \"Content-Length\";\n    const response = await fetch(url);\n    if (response.headers.has(size)) {\n      (_b = this._options).size ?? (_b.size = Number.parseInt(response.headers.get(size)));\n    }\n    this._loader.options = this._options;\n    this._loader.stream = response.body;\n    return this._loader.open(this._openedDataSource);\n  }\n  openStream(stream) {\n    this._loader.options = this._options;\n    this._loader.stream = stream;\n    return this._loader.open(this._openedDataSource);\n  }\n  openBuffer(buffer2) {\n    this._loader.options = this._options;\n    this._loader.buffer = buffer2;\n    return this._loader.open(this._openedDataSource);\n  }\n  async openSheet(data) {\n    var _a;\n    const { apiKey, sheetUrl } = data;\n    const { sheetId, type } = parseSheetId(sheetUrl);\n    const sheetService = type === \"google\" ? google : excel;\n    const range = await sheetService.fetchSheetDataRange(sheetId, apiKey);\n    const stream = await sheetService.fetchSheetValues(sheetId, apiKey, range);\n    (_a = this._options).delimiter ?? (_a.delimiter = deductDelimiter(\"csv\"));\n    this._loader.options = this._options;\n    this._loader.stream = stream;\n    return this._loader.open(this._openedDataSource);\n  }\n  openInputData(source) {\n    if (source instanceof Blob) {\n      return this.openFile(source);\n    } else if (typeof source === \"string\") {\n      return this.openUrl(source);\n    } else if (source instanceof ReadableStream) {\n      return this.openStream(source);\n    } else if (source instanceof ArrayBuffer || source instanceof SharedArrayBuffer || source instanceof Uint8Array) {\n      return this.openBuffer(source);\n    } else if (\"sheetUrl\" in source && \"apiKey\" in source) {\n      return this.openSheet(source);\n    }\n  }\n  async open(id) {\n    const dataSource = this._options.dataSources[id];\n    const data = await (typeof dataSource === \"function\" ? dataSource() : dataSource);\n    this._openedDataSource = id;\n    return this.openInputData(data);\n  }\n  load(options) {\n    this._loader.loadOptions = options;\n    return this._loader.load();\n  }\n  addDataSource(id, dataSource) {\n    this._options.dataSources[id] = dataSource;\n  }\n  removeDataSource(id) {\n    delete this._options.dataSources[id];\n  }\n}\nfunction deductDelimiter(format) {\n  switch (format?.toLowerCase()) {\n    case \"csv\":\n      return \",\";\n    case \"tsv\":\n      return \"\t\";\n    default:\n      return void 0;\n  }\n}\nexport { CSV, ColorChunk, ColorColumn, DataType, DateChunk, DateColumn, Float32Chunk, Float32Column, Float64Chunk, Float64Column, Int16Chunk, Int16Column, Int32Chunk, Int32Column, Int8Chunk, Int8Column, StringChunk, StringColumn, Uint16Chunk, Uint16Column, Uint32Chunk, Uint32Column, Uint8Chunk, Uint8Column, buildChunk, buildColumn, bytes, createDataSources, isFloat, isInt, isNumber, rebuildChunk, rebuildColumn };\n//# sourceMappingURL=cbd.js.map\n","\n/* spellchecker: disable */\n\nimport * as gloperate from 'webgl-operate';\n\nimport log = gloperate.auxiliaries.log;\nimport LogLevel = gloperate.auxiliaries.LogLevel;\n\nimport { CSV, Column, Float32Column, Float32Chunk, StringColumn, StringChunk } from '@hpicgs/cbd-parser';\n\nimport { Configuration, Topology, NodeSort } from '../../source/treemap-renderer';\nimport { delimiter } from 'path';\n\n/* spellchecker: enable */\n\n\nexport class CBDHeader {\n    public csv_delimiter: string;\n    public path_column: string;\n    public weight_column: string;\n    public height_column: string;\n    public color_column: string;\n    public label_column: string;\n    public height_scale: number;\n};\n\nclass Edge {\n    public parentIndex: number;\n    public index: number;\n};\n\nclass CBDHeaderParser {\n    protected _header: CBDHeader;\n    protected _loader: CSV;\n    protected _headerParsed = false;\n    protected _intermediateChunk = '';\n\n    public constructor(header: CBDHeader, loader: CSV) {\n        this._header = header;\n        this._loader = loader;\n    }\n\n    // do nothing on start\n    public start(): void { }\n\n    // do nothing on end\n    public flush(): void { }\n\n    public transform: TransformerTransformCallback<string, string> = async (chunk, controller) => {\n\n        if (this._headerParsed) {\n            controller.enqueue(chunk);\n\n            return;\n        }\n\n        this._intermediateChunk += chunk;\n\n        // Contains newline => let's parse the header line\n        let lastNewline = -1;\n        let nextNewline = this._intermediateChunk.indexOf('\\n', lastNewline + 1);\n        while (nextNewline != -1 && this._intermediateChunk[lastNewline + 1] == '#') {\n            const line = this._intermediateChunk.substring(lastNewline + 2, nextNewline).trim();\n\n            const [key, value] = line.split('=').map((s: string) => s.trim());\n\n            if (key == 'delimiter') {\n                this._header.csv_delimiter = value || ';';\n                this._loader._options!.delimiter = this._header.csv_delimiter;\n            } else if (key == 'paths') {\n                this._header.path_column = value || 'name';\n            } else if (key == 'weights') {\n                this._header.weight_column = value || '';\n            } else if (key == 'heights') {\n                this._header.height_column = value || '';\n            } else if (key == 'colors') {\n                this._header.color_column = value || '';\n            } else if (key == 'labels') {\n                this._header.label_column = value || '';\n            } else if (key == 'heightScale') {\n                this._header.height_scale = Number.parseFloat(value || '0.1') || 0.1;\n            } else {\n                log(LogLevel.Warning, `Unparsed header`, key, '=', value);\n            }\n\n            lastNewline = nextNewline;\n            nextNewline = this._intermediateChunk.indexOf('\\n', lastNewline + 1);\n        }\n\n        if (lastNewline > 0) {\n            this._intermediateChunk = this._intermediateChunk.substring(lastNewline + 1);\n        }\n\n        // Next line doesn't start with # => parsing headers finished\n        if (!this._intermediateChunk.startsWith('#')) {\n            controller.enqueue(this._intermediateChunk);\n\n            this._intermediateChunk = '';\n            this._headerParsed = true;\n        }\n    };\n}\n\nexport class CBDData {\n    protected static initializeHeader(header: CBDHeader): void {\n        header.csv_delimiter = ';';\n        header.path_column = 'name';\n    }\n\n    protected static parseResult(result: Array<Column>, header: CBDHeader, config: Configuration): void {\n\n        const collect_string_column = (result: Array<Column>, name: string): Array<string> => {\n            let column_index = result.findIndex((column) => column.name == name);\n            if (column_index < 0) {\n                const column = new StringColumn(name);\n                column.push(new StringChunk(result[0].length, 0, false));\n                return column;\n            }\n\n            // Return column as is\n            return result[column_index];\n        };\n\n        const collect_column = (result: Array<Column>, name: string) => {\n            let column_index = result.findIndex((column) => column.name == name);\n            if (column_index < 0) {\n                const column = new Float32Column(name);\n                column.push(new Float32Chunk(result[0].length, 0, false))\n                column.getChunk(0).view.fill(-1);\n                return column;\n            }\n\n            /*const float32Flatten = (chunks) => {\n                const flattened = new Float32Array(result[0].length);\n\n                //insert each chunk into the new float32array\n                let currentFrame = 0\n                chunks.forEach((chunk) => {\n                    flattened.set(chunk, currentFrame)\n                    currentFrame += chunk.length;\n                });\n                return flattened;\n            }*/\n\n            //return float32Flatten(result[column_index].chunks.map(chunk => chunk.view));\n\n            // Return column as is\n            return result[column_index];\n        };\n\n        const has_labels_column = (name: string) => result.findIndex((column) => column.name == name && column.type == 'string') >= 0;\n\n        // parse edges\n\n        const paths = collect_string_column(result, header.path_column).chunks.map(chunk => chunk._data).flat();\n\n        for (let i = 0; i < paths.length; ++i) {\n            paths[i] = paths[i].replace(\"./\", \"\");\n        }\n        const pathParts = paths.map((value: string) => value.split('/'));\n\n        // parse weights\n\n        const leafWeights = collect_column(result, header.weight_column);\n\n        // parse heights\n\n        const leafHeights = collect_column(result, header.height_column);\n\n        // parse colors\n\n        const leafColors = collect_column(result, header.color_column);\n\n        // parse labels\n\n        const labels = has_labels_column(header.label_column) ?\n            collect_string_column(result, header.label_column) :\n            pathParts.map((parts: string[]) => parts.at(-1));\n\n        // Load topology\n\n        const createNode = (index: number, parentIndex: number): Edge => {\n            return { parentIndex, index } as Edge;\n        };\n\n        const gatherParentKey = (parts: string[], index: number): string => {\n            return \"/\" + parts.slice(0, index).join('/');\n        }\n\n        const edges = new Array<Configuration.NodeIdentifier>();\n        const names = new Map<number, string>();\n        const weights = new Array<number>();\n        const heights = new Array<number>();\n        const colors = new Array<number>();\n\n        const nodes = {};\n        let currentIndex = -1;\n\n        // Create root\n        nodes['/'] = createNode(currentIndex, -1);\n        currentIndex += 1;\n        weights.push(0.0);\n        heights.push(0.0);\n        colors.push(0.0);\n\n        // Create inner nodes and leaf nodes\n        pathParts.forEach((parts: Array<string>, partIndex: number) => {\n            parts.forEach((value: string, index: number) => {\n                const parentKey = gatherParentKey(parts, index);\n                const key = gatherParentKey(parts, index + 1);\n\n                if (!(parentKey in nodes)) {\n                    log(LogLevel.Warning, parentKey, 'not in', nodes);\n                    return;\n                }\n\n                if (key in nodes) {\n                    // Inner node already created\n                    return;\n                }\n\n                nodes[key] = createNode(currentIndex, nodes[parentKey].index);\n                edges.push(nodes[key].parentIndex);\n                edges.push(currentIndex);\n                names.set(currentIndex, value);\n                currentIndex += 1;\n\n                if (index == parts.length - 1) {\n                    // Is leaf node\n                    weights.push(leafWeights.get(partIndex) || 0.0);\n                    heights.push(leafHeights.get(partIndex) || 0.0);\n                    colors.push(leafColors.get(partIndex) || 0.0);\n                } else {\n                    // Is inner node\n                    weights.push(0.0);\n                    heights.push(0.0);\n                    colors.push(0.0);\n                }\n            });\n        });\n\n        config.topology = {\n            edges: edges,\n            semantics: Topology.InputSemantics.ParentIdId,\n            format: Topology.InputFormat.Interleaved,\n        };\n\n        config.buffers = [\n            {\n                identifier: 'source-weights',\n                type: 'numbers',\n                data: weights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-heights',\n                type: 'numbers',\n                data: heights,\n                linearization: 'topology',\n            },\n            {\n                identifier: 'source-colors',\n                type: 'numbers',\n                data: colors,\n                linearization: 'topology',\n            }\n        ];\n\n        config.bufferViews = [\n            {\n                identifier: 'weights',\n                source: 'buffer:source-weights',\n                transformations: [\n                    { type: 'fill-invalid', value: 1.0, invalidValue: -1.0 },\n                    { type: 'propagate-up', operation: 'sum' }\n                ],\n            },\n            {\n                identifier: 'heights-normalized',\n                source: 'buffer:source-heights',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' }\n                ],\n            },\n            {\n                identifier: 'colors-normalized',\n                source: 'buffer:source-colors',\n                transformations: [\n                    { type: 'fill-invalid', value: 0.0, invalidValue: -1.0 },\n                    { type: 'normalize', operation: 'zero-to-max' }\n                ],\n            }\n        ];\n\n        config.colors = [\n            { identifier: 'emphasis', colorspace: 'hex', value: '#00b0ff' },\n            { identifier: 'auxiliary', colorspace: 'hex', values: ['#00aa5e', '#71237c'] },\n            { identifier: 'inner', colorspace: 'hex', values: ['#e8eaee', '#eef0f4'] },\n            { identifier: 'leaf', preset: 'Greens', steps: 7 },\n        ];\n\n        config.layout = {\n            algorithm: 'snake',\n            weight: 'bufferView:weights',\n            sort: {\n                key: 'bufferView:weights',\n                algorithm: NodeSort.Algorithm.Keep\n            },\n            parentPadding: { type: 'relative', value: 0.05 },\n            siblingMargin: { type: 'relative', value: 0.05 },\n            accessoryPadding: {\n                type: 'absolute',\n                direction: 'bottom',\n                value: [0.0, 0.02, 0.01, 0.0],\n                relativeAreaThreshold: 0.4, targetAspectRatio: 8.0,\n            },\n        };\n\n        config.geometry = {\n            parentLayer: { showRoot: false },\n            leafLayer: {\n                colorMap: 'color:leaf',\n                height: 'bufferView:heights-normalized',\n                colors: 'bufferView:colors-normalized',\n            },\n            emphasis: { outline: new Array<number>(), highlight: new Array<number>() },\n            heightScale: header.height_scale,\n        };\n\n        config.labels = {\n            innerNodeLayerRange: [1, 2],\n            numTopInnerNodes: 50,\n            numTopWeightNodes: 50,\n            numTopHeightNodes: 50,\n            numTopColorNodes: 50,\n            names: names,\n        };\n\n        config.altered.alter('any');\n    }\n\n    static loadAsync(file: File): Promise<Configuration> {\n        const header = new CBDHeader();\n\n        const loader = new CSV({ delimiter: ';' });\n\n        CBDData.initializeHeader(header);\n\n        const payload = file.stream()\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new TransformStream(new CBDHeaderParser(header, loader)))\n            .pipeThrough(new TextEncoderStream());\n\n        loader.addDataSource('file', payload);\n\n        return new Promise<Configuration>(async (resolve, reject) => {\n            const config = new Configuration();\n\n            const start = Date.now();\n            console.log('Start parsing:', start);\n\n            const detectedColumns = await loader.open('file');\n\n            const { columns, statistics } = await loader.load({\n                columns: detectedColumns,\n                /*\n                onInit: () => {\n                    console.log('received columns', detectedColumns);\n                    console.log(`detected ${detectedColumns!.length} columns:\\n` +\n                        detectedColumns!.map(({ name, type }) => `${name}: ${type}`).join('\\n')\n                    );\n                },*/\n                /*\n                onUpdate: (progress) => console.log(`received new data. progress: ${progress}`),\n                */\n            });\n\n            const parsed_csv = Date.now();\n            console.log('End CSV parsing:', parsed_csv, parsed_csv - start);\n\n            CBDData.parseResult(columns, header, config);\n\n            const parsed_config = Date.now();\n            console.log('End Config parsing:', parsed_config, parsed_config - parsed_csv);\n\n            console.log('Full runtime:', parsed_config - start);\n\n            resolve(config);\n        });\n    }\n\n}\n","\n\n/* spellchecker: disable */\n\nimport * as gloperate from 'webgl-operate';\n\nimport log = gloperate.auxiliaries.log;\nimport LogLevel = gloperate.auxiliaries.LogLevel;\n\nimport {\n    Configuration,\n    Renderer,\n    Visualization,\n    initialize\n} from '../../source/treemap-renderer';\n\nimport { CSVData } from './csvdata';\nimport { CBDData } from './cbddata';\n\nimport { Example } from '../example';\n\n/* spellchecker: enable */\n\n\n// tslint:disable:max-classes-per-file\n\nexport class ImplicitInnerNodesTreemapFromCSVExample extends Example {\n\n    get canvas(): gloperate.Canvas {\n        return this._canvas;\n    }\n\n    get visualization(): Visualization {\n        return this._visualization;\n    }\n\n    get renderer(): Renderer {\n        return this._renderer;\n    }\n\n    private _canvas: gloperate.Canvas;\n    private _visualization: Visualization;\n    private _renderer: Renderer;\n\n\n    validate(element: HTMLCanvasElement | string): boolean {\n        return this.initialize(element);\n        // return false;\n    }\n\n    preview(element: HTMLCanvasElement | string): boolean {\n        return this.initialize(element);\n        // return false;\n    }\n\n    feature(element: HTMLCanvasElement | string): boolean {\n\n        const success = this.initialize(element);\n\n        const renderer = this._visualization.renderer as Renderer;\n        const canvas = this._canvas as gloperate.Canvas;\n        const visualization = this._visualization;\n\n        const fullscreenTarget = canvas.element;\n\n        window.document.getElementById('fullscreen')!.onclick = () => {\n            gloperate.viewer.Fullscreen.toggle(fullscreenTarget);\n        };\n\n        const loadConfig = (config: Configuration) => {\n            const oldConfig = visualization.configuration;\n\n            try {\n                visualization.configuration = config;\n                visualization.update();\n                renderer.invalidate();\n            }\n            catch (error) {\n                console.log(error);\n\n                if (oldConfig === undefined) {\n                    return;\n                }\n\n                const rescueConfig = new Configuration();\n\n                rescueConfig.topology = oldConfig.topology;\n                rescueConfig.layout = oldConfig.layout;\n                rescueConfig.buffers = oldConfig.buffers;\n                rescueConfig.bufferViews = oldConfig.bufferViews;\n                rescueConfig.colors = oldConfig.colors;\n                rescueConfig.geometry = oldConfig.geometry;\n                rescueConfig.labels = oldConfig.labels;\n\n                visualization.configuration = rescueConfig;\n                visualization.update();\n                renderer.invalidate();\n            }\n        };\n\n        const fileUpload = document.getElementById('fileUpload') as HTMLInputElement;\n        const loadFile = document.getElementById('loadFile') as HTMLInputElement;\n\n        const loadCsv = async () => {\n            const fileList = fileUpload.files;\n            if (fileList === null) return;\n            const file = fileList[0];\n            if (file === undefined) return;\n\n            if (false) {\n                // Papaparse Interface\n                CSVData.loadAsync(file)\n                    .then((config: Configuration) => loadConfig(config));\n            } else {\n                // CBD-Parser Interface\n                CBDData.loadAsync(file)\n                    .then((config: Configuration) => loadConfig(config));\n            }\n        };\n\n        loadFile.onclick = async () => loadCsv();\n\n        // export variables\n\n        (window as any)['gloperate'] = gloperate;\n\n        (window as any)['canvas'] = canvas;\n        (window as any)['context'] = canvas.context;\n        (window as any)['controller'] = canvas.controller;\n\n        (window as any)['visualization'] = visualization;\n        (window as any)['renderer'] = renderer;\n\n        return success;\n    }\n\n\n    initialize(element: HTMLCanvasElement | string): boolean {\n\n        this._canvas = initialize(element);\n\n        this._visualization = new Visualization();\n        const renderer: Renderer = this._visualization.renderer as Renderer;\n        this._canvas.renderer = renderer;\n\n        super.expose();\n\n        return true;\n    }\n\n    uninitialize(): void {\n        this._canvas.dispose();\n        (this._renderer as gloperate.Renderer).uninitialize();\n    }\n}\n","\n        import { ImplicitInnerNodesTreemapFromCSVExample } from './treemap.ts';\n\n        window.onload = function () {\n\n            const canvas = document.getElementById('canvas');\n            const exampleRenderer = new ImplicitInnerNodesTreemapFromCSVExample();\n            window['example'] = exampleRenderer;\n            exampleRenderer.feature(canvas);\n\n            const aboutCode = window.document.getElementById('context-about');\n            if (aboutCode) {\n                aboutCode.innerText = context.aboutString();\n            }\n        };\n    ","\n        import * as treemaprenderer from '/examples/index.ts';\n        window['treemaprenderer'] = treemaprenderer;\n        document.title = __LIB_NAME__;\n        document.querySelector('#version').innerHTML = treemaprenderer.version();\n        document.querySelector('#branch').innerHTML = treemaprenderer.branch();\n        document.querySelector('#commit').innerHTML = treemaprenderer.commit();\n        document.querySelector('#cryear').innerHTML = new Date().getFullYear();\n    "],"names":["gloperate.auxiliaries","GoogleCsvTransformer","chunk","controller","searchString","rows","start","row","value","calculateEndColumn","columnCount","columnName","mod","fetchSheetData$1","route","fetchSheetDataRange$1","sheetId","apiKey","response","sheets","title","rowCount","fetchSheetValues$1","range","google","ExcelCsvTransformer","searchIndex","char","fetchSheetData","apiToken","headers","fetchSheetDataRange","name","fetchSheetValues","tableName","excel","parseSheetId","sheetUrl","url","type","DataType","DataType2","bytes","DEFAULT_ALPHA","HEX_FORMAT_REGEX","hex2rgba","hex","failSilent","rgba","offset","length","stride","inferType","input","col","lowestType","a","b","set","splitLines","lines","remainder","newLine","hasReturn","str","parse","chunks","end","parseSingleChunk","decoder","buffer2","PerfMon","id","label","sample","splitLine","line","delimiter","cells","quote","quoteActive","push","i","skip","cellEnd","index","buffer","shared","BaseChunk","BufferChunk","ColorChunk","DateChunk","time","BaseNumberChunk","bytes2","Int8Chunk","Uint8Chunk","Int16Chunk","Uint16Chunk","Int32Chunk","Uint32Chunk","Float32Chunk","Float64Chunk","StringChunk","buildChunk","rebuildChunk","nc","BaseColumn","c","altered","ColorColumn","DateColumn","BaseNumberColumn","Int8Column","Uint8Column","Int16Column","Uint16Column","Int32Column","Uint32Column","Float32Column","Float64Column","StringColumn","buildColumn","MessageType","MessageType2","Loader","result","acd","msg","nextResult","data","l","inferStart","lines2","columns","prev","cur","resolve","reject","event","message2","progress","_b","_a","setup","column","message","statistics","stream","options","CSV","file","deductDelimiter","size","sheetService","source","dataSource","format","log","LogLevel","CBDHeader","CBDHeaderParser","header","loader","lastNewline","nextNewline","key","s","CBDData","config","collect_string_column","column_index","collect_column","has_labels_column","paths","pathParts","leafWeights","leafHeights","leafColors","parts","createNode","parentIndex","gatherParentKey","edges","names","weights","heights","colors","nodes","currentIndex","partIndex","parentKey","Topology","NodeSort","payload","Configuration","detectedColumns","parsed_csv","parsed_config","ImplicitInnerNodesTreemapFromCSVExample","Example","element","success","renderer","canvas","visualization","fullscreenTarget","gloperate.viewer","loadConfig","oldConfig","error","rescueConfig","fileUpload","loadFile","loadCsv","fileList","gloperate","initialize","Visualization","exampleRenderer","aboutCode","treemaprenderer","treemaprenderer.version","treemaprenderer.branch","treemaprenderer.commit"],"mappings":"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","x_google_ignoreList":[1]}